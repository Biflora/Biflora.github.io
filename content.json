{"meta":{"title":"Biflora's Blog","subtitle":"街路、ライトの灯りだけW花と水飴、最終電車W朝焼けた色 空を舞ってW一瞬、それで良いんだW校舎、春、進路票、朝焼けの空W昼顔、鳥居、鳳仙花、バス停Wアベリア、始発、終電車、緑青W海辺の町、昼青い空W青春なんていらないわW明日の私にはもう期待しないでW朝焼け、朱、赤、空に溶けるW夜に染まるまでW理由もないような僕らの歌ったW夏の匂いがしているWあなたを降ろして青を残したW夏は白かったWシロツメクサのように冬を待っていた","description":"ただ君に晴れ","author":"Biflora","url":"http://yoursite.com"},"pages":[{"title":"归档","date":"2019-02-04T06:07:02.000Z","updated":"2019-02-06T00:42:31.567Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-02-04T06:05:59.000Z","updated":"2019-02-06T17:46:25.624Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"音だけでも泣いてしまう 「只听声音就已泫然欲泣」 $About \\ Me$ 现就读于AHSFNU(福师大附中)的蒟蒻一只 目前是一名菜鸡OIer 估计以后也是菜鸡 梦想是和某人一起在日内瓦湖边某所学府读书(笑 $About \\ Biflora$ 发音无~所~谓(故作某雷状 出自于一首$\\textbf{ナブナ}$老师的歌中有一个词 $\\textbf{アベリア}$ 我当时并不知道是什么东西(... 查了一下发现是一种叫做六道木的花(? 学名叫做 $Abelia \\ Biflora$ 于是.... 以上、"},{"title":"分类","date":"2019-02-04T06:06:49.000Z","updated":"2019-02-06T00:42:21.084Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"home","date":"2019-02-04T06:06:34.000Z","updated":"2019-02-04T06:06:34.914Z","comments":true,"path":"home/index.html","permalink":"http://yoursite.com/home/index.html","excerpt":"","text":""},{"title":"search","date":"2019-02-06T00:08:00.000Z","updated":"2019-02-06T00:08:21.408Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-04T06:05:41.000Z","updated":"2019-02-06T00:43:05.996Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[TJOI2010]阅读理解","slug":"阅读理解","date":"2019-02-23T15:54:54.000Z","updated":"2019-02-23T15:56:37.457Z","comments":true,"path":"2019/02/23/阅读理解/","link":"","permalink":"http://yoursite.com/2019/02/23/阅读理解/","excerpt":"[TJOI2010]阅读理解 $Description$给出$n$篇文章,每篇文章有$l$个单词,再给出$m$个单词,求出这$m$个词在哪几篇文章中出现过 对于100%的数据,$n\\le 1000,m\\le 10000$","text":"[TJOI2010]阅读理解 $Description$给出$n$篇文章,每篇文章有$l$个单词,再给出$m$个单词,求出这$m$个词在哪几篇文章中出现过 对于100%的数据,$n\\le 1000,m\\le 10000$ $Solution$本来开个map直接随便草过去了但是这是字典树(Trie)的裸题就不偷懒了Trie很巧妙地把不同的具有公共前缀的单词建在同一条链上这样查询的复杂度就会低很多就是空间有点大,还算错了好几次(菜那么这题就很简单了直接建出一棵Trie标记每个单词出现的文章查询的时候遍历一下就可以了 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define N 100010using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;char s[30];int trie[1000010][26],n,cnt,rt,m;bool vis[1001][1000001];void ins(char *s,int root,int x)&#123; for(int i=0;s[i];i++)&#123; int k=s[i]-'a'; if(!trie[root][k])trie[root][k]=++cnt; root=trie[root][k]; &#125; vis[x][root]=true;&#125;void check(char *s,int root)&#123; bool flag=false; for(int i=0;s[i];i++)&#123; int k=s[i]-'a'; if(!trie[root][k])&#123; flag=true; break; &#125; root=trie[root][k]; &#125; if(!flag)&#123; for(int i=1;i&lt;=n;i++)&#123; if(vis[i][root])&#123; printf(\"%d \",i); &#125; &#125; &#125; cout&lt;&lt;endl;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; int l=read(); for(int j=1;j&lt;=l;j++)&#123; cin&gt;&gt;s; ins(s,rt,i); &#125; &#125; m=read(); for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;s; check(s,rt); &#125; return 0;&#125; 以上、","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://yoursite.com/tags/Trie/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"[SCOI2014]方伯伯运椰子","slug":"[SCOI2014]方伯伯运椰子","date":"2019-02-23T15:33:06.000Z","updated":"2019-02-23T15:40:34.967Z","comments":true,"path":"2019/02/23/[SCOI2014]方伯伯运椰子/","link":"","permalink":"http://yoursite.com/2019/02/23/[SCOI2014]方伯伯运椰子/","excerpt":"[SCOI2014]方伯伯运椰子 $Description$给出$n+2$个点,$m$条边,每条边用$E$={$u,v,a,b,c,d$}表示,即$u$到$v$有一条容量为$c$的边,每单位运输量需要$d$的费用,压缩一次容量需要$a$的费用,扩容一次需要$b$的费用。 要保证每条边满负荷且总交通量(流量)不变,设调整前费用为$X$,调整之后的费用为$Y$,进行了$k$次调整,求$(X-Y)/k$的最大值","text":"[SCOI2014]方伯伯运椰子 $Description$给出$n+2$个点,$m$条边,每条边用$E$={$u,v,a,b,c,d$}表示,即$u$到$v$有一条容量为$c$的边,每单位运输量需要$d$的费用,压缩一次容量需要$a$的费用,扩容一次需要$b$的费用。 要保证每条边满负荷且总交通量(流量)不变,设调整前费用为$X$,调整之后的费用为$Y$,进行了$k$次调整,求$(X-Y)/k$的最大值 $Solution$看到式子可以很容易看出是一个分数规划的模型,考虑调整比率 $mid\\times k-(X-Y)\\ge 0$ 考虑如何判断上述式子是否成立第一个想到费用流,考虑建图$X-Y$可以看作$\\Delta cost$那么考虑扩容和压缩如何处理扩容很显然费用即$b+d$那么压缩则应该是建$v$到$u$费用为$a-d$,且要满足容量$c&gt;0$这样就可以处理出$\\Delta cost$因为此时边权为扩容or压缩一次产生的$\\Delta cost’$,那么对于图中每一个环都应该满足环上点数$n$都应该满足 $ans\\times n'-\\Delta cost' \\ge 0$ 这时$k$就是环上的点数$n’$了那么就可以知道,当$mid\\ge ans$时 $mid\\times n'-\\Delta cost' \\ge 0$ 反之 $mid\\times n’-\\Delta cost’&lt;0 $ 说明当图上存在负环时仍有更优解那么就可以直接用spfa判负环去判断$mid$的合法性了 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define eps 1e-3#define N 5010#define INF 0x7fffffffusing namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N&lt;&lt;1];int head[N],cnt,n,m;bool vis[N],flag;double dis[N];void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;bool spfa(int u,double mid)&#123; vis[u]=true; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w+mid)&#123; dis[v]=dis[u]+w+mid; if(vis[v])return true; if(spfa(v,mid))return true; &#125; &#125; vis[u]=false; return false;&#125;bool check(double mid)&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); flag=false; for(int i=1;i&lt;=n;i++)&#123; if(spfa(i,mid))return true; &#125; return false;&#125;int main()&#123; n=read()+2,m=read(); for(int i=1;i&lt;=m;i++)&#123; int u=read(),v=read(),a=read(),b=read(),c=read(),d=read(); if(c)add(v,u,a-d); add(u,v,b+d); &#125; double l=0.00,r=1000000000.00,mid; while(r-l&gt;=eps)&#123; mid=(l+r)/2; if(check(mid))l=mid; else r=mid; &#125; printf(\"%.2lf\",l); return 0;&#125; 以上、","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"分数规划","slug":"分数规划","permalink":"http://yoursite.com/tags/分数规划/"},{"name":"负环","slug":"负环","permalink":"http://yoursite.com/tags/负环/"}]},{"title":"[SDOI 2017]  新生舞会","slug":"新生舞会","date":"2019-02-08T08:56:35.000Z","updated":"2019-02-08T08:58:54.484Z","comments":true,"path":"2019/02/08/新生舞会/","link":"","permalink":"http://yoursite.com/2019/02/08/新生舞会/","excerpt":"[SDOI 2017] 新生舞会 $Description$给定$n$个男生,$n$个女生,每一个男生对应每一个女生都有一个$a_{i,j}$同时每一个男生对应每一个女生有一个$b_{i,j}$令$C=\\frac{\\sum a_i}{\\sum b_i}$,试求出$C$最大值","text":"[SDOI 2017] 新生舞会 $Description$给定$n$个男生,$n$个女生,每一个男生对应每一个女生都有一个$a_{i,j}$同时每一个男生对应每一个女生有一个$b_{i,j}$令$C=\\frac{\\sum a_i}{\\sum b_i}$,试求出$C$最大值 $Solution$化简该式子 $\\sum a_i-C*\\sum b_i=0$ 照样二分一个$mid$,因为给出一张二分图,所以尝试用费用流来判$mid​$的合法性考虑如何建图建源汇,源点连男生,男生连女生,女生连汇点,边的容量均为1考虑费用的分配既然要满足 $\\sum a_i-mid*\\sum b_i\\ge0$ 那不妨将男女之间连边的费用设为$a_{i,j}-mid\\times b_{i,j}$这样跑一遍最大费用最大流,再试判断最大费用是否满足上式这题卡常(开了O2还是跑了800+ms $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;const double eps=1e-7;const int N=5005;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct node&#123; int v,nxt,w; double c;&#125;e[N&lt;&lt;2];int head[N&lt;&lt;1],cnt=-1;int flow[N&lt;&lt;1],pre[N&lt;&lt;1],las[N&lt;&lt;1];double dis[N&lt;&lt;1];bool vis[N];double a[101][101],b[101][101];int ans1,s,t,n,m;double ans2;void add(int u,int v,int w,double c)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].c=c; e[cnt].nxt=head[u]; head[u]=cnt; e[++cnt].v=u; e[cnt].w=0; e[cnt].c=-c; e[cnt].nxt=head[v]; head[v]=cnt;&#125;void clear()&#123; memset(head,-1,sizeof(head)); memset(pre,0,sizeof(pre)); memset(las,0,sizeof(las)); ans1=ans2=0; cnt=-1;&#125;bool spfa()&#123; queue&lt;int&gt; q; memset(dis,-0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(flow,0x3f,sizeof(flow)); q.push(s); vis[s]=true;dis[s]=0;pre[t]=-1; while(!q.empty())&#123; int u=q.front(); q.pop();vis[u]=false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; double c=e[i].c; if(w&amp;&amp;dis[v]&lt;dis[u]+c)&#123; dis[v]=dis[u]+c; pre[v]=u; las[v]=i; flow[v]=min(flow[u],w); if(!vis[v])&#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]!=-1)return true; return false; &#125;void mcmf()&#123; while(spfa())&#123; int now=t; ans2+=(double)flow[now]*dis[now]; while(now!=s)&#123; e[las[now]].w-=flow[t]; e[las[now]^1].w+=flow[t]; now=pre[now]; &#125; &#125;&#125;bool check(double x)&#123; clear(); for(int i=1;i&lt;=n;i++)add(s,i,1,0); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; add(i,j+n,1,-x*b[i][j]+a[i][j]); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; add(i+n,t,1,0); &#125; mcmf(); return ans2&gt;0;&#125;int main()&#123; n=read(); s=0,t=n*2+3; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;b[i][j]; &#125; &#125; double l=0,r=1e4; while(r-l&gt;=eps)&#123; double mid=(l+r)/2; if(check(mid))l=mid; else r=mid; &#125; printf(\"%.6lf\",l); return 0;&#125; 以上、 ​​​","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"MCMF","slug":"MCMF","permalink":"http://yoursite.com/tags/MCMF/"},{"name":"分数规划","slug":"分数规划","permalink":"http://yoursite.com/tags/分数规划/"}]},{"title":"[USACO18] Talent Show","slug":"Talent-Show","date":"2019-02-07T14:26:31.000Z","updated":"2019-02-07T14:49:14.872Z","comments":true,"path":"2019/02/07/Talent-Show/","link":"","permalink":"http://yoursite.com/2019/02/07/Talent-Show/","excerpt":"Luogu P4377 $Description$给定$n​$个物品和一个$V​$,每个物品有一个$t_i​$和$w_i​$属性请选出一部分物品使 $\\frac{\\sum t_i}{\\sum w_i}​$最大,且$\\sum w_i \\ge V​$","text":"Luogu P4377 $Description$给定$n​$个物品和一个$V​$,每个物品有一个$t_i​$和$w_i​$属性请选出一部分物品使 $\\frac{\\sum t_i}{\\sum w_i}​$最大,且$\\sum w_i \\ge V​$ $Solution$水题,0/1分数规划的基础上加上一个小限制根据原式子 $\\sum t_i-\\sum w_i*mid>0$可以用01背包检查二分出的$mid$的合法性即$f[V]>0$注意开long long(偷懒就define int long long了) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define int long long const int V=10010;const int N=400;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int f[V],w[N],t[N];int n,v,inf;bool check(int x)&#123; memset(f,128,sizeof(f)); inf=f[1];f[0]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=v;j&gt;=0;j--)&#123; if(f[j]!=inf)&#123; f[min(v,j+w[i])]=max(f[min(v,j+w[i])],f[j]+t[i]-w[i]*x); &#125; &#125; &#125; return f[v]&gt;=0;&#125;signed main()&#123; n=read(),v=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read();t[i]=read(); t[i]*=1000; &#125; int l=0,r=1000000; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1; else r=mid-1; &#125; printf(\"%lld\",l-1); return 0;&#125; 以上、","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"分数规划","slug":"分数规划","permalink":"http://yoursite.com/tags/分数规划/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/背包/"}]},{"title":"[POI2015] Pustynia","slug":"POI2015-Pustynia","date":"2019-02-07T12:10:52.000Z","updated":"2019-02-07T14:50:00.476Z","comments":true,"path":"2019/02/07/POI2015-Pustynia/","link":"","permalink":"http://yoursite.com/2019/02/07/POI2015-Pustynia/","excerpt":"Luogu P3588 $Description$给定一个长度为$n$的$a$正整数序列,$a_imax=1e9$,并给出$s$个数列中已知的数.现给出$m$条信息,信息内容如下:给定$l,r,k$,接下来给出$k$个数要保证这$k$个数大于剩下$r-l-k+1$个数若无解,则输出NIE,否则,输出TAK,并给出序列$a$","text":"Luogu P3588 $Description$给定一个长度为$n$的$a$正整数序列,$a_imax=1e9$,并给出$s$个数列中已知的数.现给出$m$条信息,信息内容如下:给定$l,r,k$,接下来给出$k$个数要保证这$k$个数大于剩下$r-l-k+1$个数若无解,则输出NIE,否则,输出TAK,并给出序列$a$ $Solution$这道题的弱化版SCOI 2011 糖果弱化版为差分约束裸题,也可以用缩点+拓扑排序解决题中每一个$a_i&lt;a_j$的约束条件也可以化成拓扑排序找环以求解给出区间的$k$个点把该区间分成$k+1$个子区间因为给出的$pos_i$单调递增,区间连续那就可以用线段树优化建边了判无解有三种情况: 该节点已知但该点可取最小值大于该值 该节点可取最小值超出范围 存在环 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;const int N=500100;const int INF=1e9;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N&lt;&lt;3];int head[N&lt;&lt;2],cnt;int deg[N&lt;&lt;2],a[N&lt;&lt;2],dis[N&lt;&lt;2];int n,m,s,temp;bool vis[N&lt;&lt;2];void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].w=w; deg[v]++;&#125;int t[N&lt;&lt;2];void build(int k,int l,int r)&#123; if(l==r)&#123; t[k]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); t[k]=++temp; add(t[k&lt;&lt;1],t[k],0); add(t[k&lt;&lt;1|1],t[k],0);&#125;void update(int k,int l,int r,int L,int R,int u)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(t[k],u,0); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)update(k&lt;&lt;1,l,mid,L,R,u); if(mid&lt;R)update(k&lt;&lt;1|1,mid+1,r,L,R,u);&#125;void ins()&#123; n=read(),s=read(),m=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=s;i++)&#123; int pos=read(),x=read(); a[pos]=dis[pos]=x; &#125; for(int i=1;i&lt;=m;i++)&#123; int l=read(),r=read(),k=read(),x; int pre=l; ++temp; for(int j=1;j&lt;=k;j++)&#123; x=read(); add(temp,x,1); if(x&gt;pre)update(1,1,n,pre,x-1,temp); pre=x+1; &#125; if(x&lt;r)update(1,1,n,x+1,r,temp); &#125;&#125;void topo()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++)&#123; if(!dis[i])dis[i]=1; if(!deg[i])q.push(i); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); vis[u]=true; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; dis[v]=max(dis[v],dis[u]+w); if(!--deg[v])q.push(v); &#125; &#125;&#125;int main()&#123; ins();// for(int i=1;i&lt;=n;i++)&#123;// cout&lt;&lt;deg[i]&lt;&lt;\" \";// &#125; topo();// for(int i=1;i&lt;=n;i++)&#123;// printf(\"%d \",dis[i]);// &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]||dis[i]&gt;INF||(dis[i]&gt;a[i]&amp;&amp;a[i]))&#123; cout&lt;&lt;\"NIE\"&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;\"TAK\"&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; printf(\"%d \",dis[i]); &#125; return 0;&#125; 以上、","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://yoursite.com/tags/拓扑排序/"}]},{"title":"Flows","slug":"Flows","date":"2019-02-06T11:54:39.000Z","updated":"2019-02-08T14:38:45.829Z","comments":true,"path":"2019/02/06/Flows/","link":"","permalink":"http://yoursite.com/2019/02/06/Flows/","excerpt":"网络流总结 $1. \\ Code$ 最大流","text":"网络流总结 $1. \\ Code$ 最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//dinic#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N*4];int head[N],cnt=-1;int n,m,s,t,sum;int cur[N],deep[N];int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void ins()&#123; &#125;bool bfs()&#123; memset(deep,0,sizeof(deep)); queue&lt;int&gt; q; q.push(s); deep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(!deep[v]&amp;&amp;w)&#123; deep[v]=deep[u]+1; q.push(v); &#125; &#125; &#125; if(deep[t])return true; return false;&#125;int dfs(int u,int value)&#123; if(u==t)return value; for(int&amp; i=cur[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(deep[v]==deep[u]+1&amp;&amp;w)&#123; int now=dfs(v,min(value,w)); if(now)&#123; e[i].w-=now; e[i^1].w+=now; return now; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int ans=0; while(bfs())&#123; for(int i=s;i&lt;=t;i++)&#123; cur[i]=head[i]; &#125; while(int d=dfs(s,INF))ans+=d; &#125; return ans;&#125;int main()&#123; memset(head,-1,sizeof(head)); ins(); return 0;&#125; 最小费用最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//minimum cost maximum flow#include&lt;bits/stdc++.h&gt;#define int long long #define INF 0x7fffffffconst int N=10010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w; int cost;&#125;e[N*10];int head[N],cnt=-1;int flow[N],dis[N],pre[N],las[N];int w[N];int ans1,ans2;bool vis[N];int n,s,t,p,m,f,q,k;void add(int u,int v,int w,int c)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].cost=c;&#125;void ins()&#123; &#125;bool spfa()&#123; queue&lt;int&gt; q; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(flow,0x3f,sizeof(flow)); q.push(s); vis[s]=true;dis[s]=0;pre[t]=-1; while(!q.empty())&#123; int u=q.front(); q.pop();vis[u]=false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w,c=e[i].cost; if(w&amp;&amp;dis[v]&gt;dis[u]+c)&#123; dis[v]=dis[u]+c; pre[v]=u; las[v]=i; flow[v]=min(flow[u],w); if(!vis[v])&#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]!=-1)return true; return false; &#125;void mcmf()&#123; while(spfa())&#123; int now=t; ans1+=flow[now]; ans2+=flow[now]*dis[now]; while(now!=s)&#123; e[las[now]].w-=flow[t]; e[las[now]^1].w+=flow[t]; now=pre[now]; &#125; &#125;&#125;signed main()&#123; return 0;&#125; $2. \\ Problems$ Luogu P1231 教辅的组成若直接建图会导致一本书用多次,考虑将书拆成两个点,建超源超汇直接跑dinic即可 BZOJ1001&amp;&amp;Luogu P4001 狼抓小粉兔根据最大流=最小割=对偶图最短路,根据题意无向图直接建双向边即可 Luogu P2057 SHOI2007 善意的投票先按同意不同意建出两个$S$和$T$不同的集合,直接根据是否是朋友连双向边即可,最小割=最大流 Luogu P3410 拍照经典的最大权闭合子图例题, $s​$连正权点$v_i​$,$t​$连负权点$v_i​$,边容量为$\\left| w_v\\right|​$ 相关点连边$E​${$u,v,inf​$} 跑最小割,$ans=​$$\\sum w_i -​$最小割 若求方案,在残余网格图中瞎搞就行了 Luogu P3980 [NOI2008] 志愿者招募(!) 题意大概如下: 有$n$天每天需要$a_i$个人,有$m$种志愿者,每种志愿者包含如下信息 每种志愿者可以从$s_i$天工作到$t_i$天,每个人价格为$c_i$元,人数无限制 考虑如何建图 题目的限制条件是第$i$天要至少有$a_i$个人 直接建图是不可取的,每天需要的人力不同 对于一个志愿者{$s_i,t_i,c_i$} 可以用一条边来表示其覆盖$s_i$到$t_i$的全部区域,费用为$c_i$ 考虑流量分配 源点连第一天流量为INF,汇点连$n+1$个点流量为INF 既然要满足志愿者可以连续工作且每天至少$a_i$人 那么不妨直接将最大流分配至INF 让每一天连下一天的流量为INF-$a_i$ 对于每种志愿者连一条边$E${$s_i,t_i+1,inf,c_i$} 连续工作的志愿者可以走相邻天数的边,即无费用的边 但又需要$a_i$的流量才能保证满流 这样就可以让志愿者填上去,就保证费用和人数限制的正确性了 Luogu P2774 方格取数问题典型的黑白染色建二分图,分奇点和偶点建二分图$s$连黑点,容量为点权,黑连白,容量INF,白连$t$,容量为点权假设全局都选求出全局和 再求出最小割答案即为全局和-最小割 Luogu P2944 地震损失题意:已确定几个点不割,求最少割几个点使图不连通因为是割点不是割边,所以要拆点已确定点:入点出点容量为inf未确定点:入点出点容量为1根据题意直接建图,对于一条道路建双向容量无限的边跑dinic即可","categories":[{"name":"Notes","slug":"Notes","permalink":"http://yoursite.com/categories/Notes/"}],"tags":[{"name":"最大流","slug":"最大流","permalink":"http://yoursite.com/tags/最大流/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"MCMF","slug":"MCMF","permalink":"http://yoursite.com/tags/MCMF/"}]},{"title":"CF786B Legacy","slug":"CF786B","date":"2019-02-06T03:01:17.000Z","updated":"2019-02-07T14:48:36.056Z","comments":true,"path":"2019/02/06/CF786B/","link":"","permalink":"http://yoursite.com/2019/02/06/CF786B/","excerpt":"CF 786B Legacy $Description$ 有$n​$颗星球,$q​$种方案,$s​$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \\lbrack l_i,r_i \\rbrack$星球花费为$w_i$ 从$ \\lbrack l_i,r_i \\rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费","text":"CF 786B Legacy $Description$ 有$n​$颗星球,$q​$种方案,$s​$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \\lbrack l_i,r_i \\rbrack$星球花费为$w_i$ 从$ \\lbrack l_i,r_i \\rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费 $ Solution $ 处理区间建边显然是不能直接暴力加边的 考虑建一个虚点使加的边数量变少,而处理区间问题很好用的线段树就可以用上了 如图所示,建两棵线段树,分别自顶向下加边和自下向顶加边,分别对应单点向区间加边和区间向单点加边 只要在建出的图上跑一遍$dij$就过了 注意点:点数有$n$+$2nlogn$,边数最多有$2nlogn$+$mlogn$,数组要开大(一人血书提醒$Code$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct edge&#123; int v,nxt,w;&#125;e[N*20];int head[N&lt;&lt;4],cnt;long long inf;int n,m,s;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;int tin[N&lt;&lt;4],tout[N&lt;&lt;4],temp;long long dis[N&lt;&lt;4];void build(int k,int l,int r)&#123; if(l==r)&#123; tin[k]=tout[k]=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tin[k]=++temp;tout[k]=++temp; add(tout[k&lt;&lt;1],tout[k],0); add(tout[k&lt;&lt;1|1],tout[k],0); add(tin[k],tin[k&lt;&lt;1],0); add(tin[k],tin[k&lt;&lt;1|1],0);&#125;void update1(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(u,tin[k],w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update1(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update1(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;void update2(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(tout[k],u,w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update2(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update2(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;struct node&#123; int u; long long d; bool operator&lt;(const node&amp;h)const&#123;return d&gt;h.d;&#125;;&#125;;void dij()&#123; memset(dis,0x3f,sizeof(dis)); inf=dis[1]; priority_queue&lt;node&gt; q; dis[s]=0; q.push((node)&#123;s,0&#125;); while(!q.empty())&#123; node now=q.top(); int u=now.u; long long d=now.d; q.pop(); if(d!=dis[u])continue; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),s=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int opt=read(); if(opt==1)&#123; int x=read(),y=read(),z=read(); add(x,y,z); &#125; else if(opt==2)&#123; int u=read(),l=read(),r=read(),w=read(); update1(1,1,n,l,r,u,w); &#125; else&#123; int u=read(),l=read(),r=read(),w=read(); update2(1,1,n,l,r,u,w); &#125; &#125; dij(); for(int i=1;i&lt;=n;i++)&#123; if(dis[i]!=inf)&#123; printf(\"%I64d \",dis[i]); &#125; else printf(\"-1 \"); &#125; return 0;&#125; 以上、","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"},{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"Hello World","slug":"Hello-World","date":"2019-02-05T22:40:23.000Z","updated":"2019-02-05T22:51:00.340Z","comments":true,"path":"2019/02/06/Hello-World/","link":"","permalink":"http://yoursite.com/2019/02/06/Hello-World/","excerpt":"","text":"Hello World 咕到春节才写第一篇并且上线 语文差点垫底所以文笔较差多见谅(…以后估计也不会有什么长进 该博客大多是和OI相关的题解/游记/学习笔记/…有关的 也会发部分个人的总结之类的(?本质问号bot 12345#include&lt;cstdio&gt;int main()&#123; puts(\"Hello World\"); return 0;&#125; 以上、","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/tags/Diary/"}]}]}