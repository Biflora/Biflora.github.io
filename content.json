{"meta":{"title":"Biflora's Blog","subtitle":"梅雨时期靛蓝色的开晴","description":"朝暮色中,独你一人又再次变得透明","author":"Biflora","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2019-02-04T06:05:59.000Z","updated":"2019-02-06T13:01:54.156Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"归档","date":"2019-02-04T06:07:02.000Z","updated":"2019-02-06T00:42:31.567Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"home","date":"2019-02-04T06:06:34.000Z","updated":"2019-02-04T06:06:34.914Z","comments":true,"path":"home/index.html","permalink":"http://yoursite.com/home/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-02-04T06:06:49.000Z","updated":"2019-02-06T00:42:21.084Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-02-06T00:08:00.000Z","updated":"2019-02-06T00:08:21.408Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-04T06:05:41.000Z","updated":"2019-02-06T00:43:05.996Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flows","slug":"Flows","date":"2019-02-06T11:54:39.000Z","updated":"2019-02-06T12:58:22.726Z","comments":true,"path":"2019/02/06/Flows/","link":"","permalink":"http://yoursite.com/2019/02/06/Flows/","excerpt":"网络流总结 $1. \\ Code$ 最大流","text":"网络流总结 $1. \\ Code$ 最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//dinic#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N*4];int head[N],cnt=-1;int n,m,s,t,sum;int cur[N],deep[N];int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void ins()&#123; &#125;bool bfs()&#123; memset(deep,0,sizeof(deep)); queue&lt;int&gt; q; q.push(s); deep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(!deep[v]&amp;&amp;w)&#123; deep[v]=deep[u]+1; q.push(v); &#125; &#125; &#125; if(deep[t])return true; return false;&#125;int dfs(int u,int value)&#123; if(u==t)return value; for(int&amp; i=cur[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(deep[v]==deep[u]+1&amp;&amp;w)&#123; int now=dfs(v,min(value,w)); if(now)&#123; e[i].w-=now; e[i^1].w+=now; return now; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int ans=0; while(bfs())&#123; for(int i=s;i&lt;=t;i++)&#123; cur[i]=head[i]; &#125; while(int d=dfs(s,INF))ans+=d; &#125; return ans;&#125;int main()&#123; memset(head,-1,sizeof(head)); ins(); return 0;&#125; 最小费用最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//minimum cost maximum flow#include&lt;bits/stdc++.h&gt;#define int long long #define INF 0x7fffffffconst int N=10010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w; int cost;&#125;e[N*10];int head[N],cnt=-1;int flow[N],dis[N],pre[N],las[N];int w[N];int ans1,ans2;bool vis[N];int n,s,t,p,m,f,q,k;void add(int u,int v,int w,int c)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].cost=c;&#125;void ins()&#123; &#125;bool spfa()&#123; queue&lt;int&gt; q; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(flow,0x3f,sizeof(flow)); q.push(s); vis[s]=true;dis[s]=0;pre[t]=-1; while(!q.empty())&#123; int u=q.front(); q.pop();vis[u]=false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w,c=e[i].cost; if(w&amp;&amp;dis[v]&gt;dis[u]+c)&#123; dis[v]=dis[u]+c; pre[v]=u; las[v]=i; flow[v]=min(flow[u],w); if(!vis[v])&#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]!=-1)return true; return false; &#125;void mcfc()&#123; while(spfa())&#123; int now=t; ans1+=flow[now]; ans2+=flow[now]*dis[now]; while(now!=s)&#123; e[las[now]].w-=flow[t]; e[las[now]^1].w+=flow[t]; now=pre[now]; &#125; &#125;&#125;signed main()&#123; return 0;&#125; $2. \\ Problems$ Luogu P1231 教辅的组成若直接建图会导致一本书用多次,考虑将书拆成两个点,建超源超汇直接跑dinic即可 BZOJ1001&amp;&amp;Luogu P4001 狼抓小粉兔 根据最大流=最小割=对偶图最短路,根据题意无向图直接建双向边即可 Luogu P2057 SHOI2007 善意的投票先按同意不同意建出两个$S$和$T$不同的集合,直接根据是否是朋友连双向边即可,最小割=最大流 Luogu P3410 拍照经典的最大权闭合子图例题, $s$连正权点$v_i$,$t$连负权点$v_i$,边容量为$\\left| w_v\\right|$ 相关点连边$E${$u,v,inf$} 跑最小割,$ans=$$\\sum w_i -​$最小割 若求方案,在残余网格图中瞎搞就行了 $\\bigstar$ Luogu P3980 [NOI2008] 志愿者招募(!) 未完成…","categories":[{"name":"Notes","slug":"Notes","permalink":"http://yoursite.com/categories/Notes/"}],"tags":[{"name":"最大流","slug":"最大流","permalink":"http://yoursite.com/tags/最大流/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"MCMF","slug":"MCMF","permalink":"http://yoursite.com/tags/MCMF/"}]},{"title":"CF786B Legacy","slug":"CF786B","date":"2019-02-06T03:01:17.000Z","updated":"2019-02-06T12:58:38.718Z","comments":true,"path":"2019/02/06/CF786B/","link":"","permalink":"http://yoursite.com/2019/02/06/CF786B/","excerpt":"http://codeforces.com/problemset/problem/786/B $Description$ 有$n$颗星球,$q$种方案,$s$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \\lbrack l_i,r_i \\rbrack$星球花费为$w_i$ 从$ \\lbrack l_i,r_i \\rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费","text":"http://codeforces.com/problemset/problem/786/B $Description$ 有$n$颗星球,$q$种方案,$s$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \\lbrack l_i,r_i \\rbrack$星球花费为$w_i$ 从$ \\lbrack l_i,r_i \\rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费 $ Solution $ 处理区间建边显然是不能直接暴力加边的 考虑建一个虚点使加的边数量变少,而处理区间问题很好用的线段树就可以用上了 如图所示,建两棵线段树,分别自顶向下加边和自下向顶加边,分别对应单点向区间加边和区间向单点加边 只要在建出的图上跑一遍$dij$就过了 注意点:点数有$n$+$2nlogn$,边数最多有$2nlogn$+$mlogn$,数组要开大(一人血书提醒$Code$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct edge&#123; int v,nxt,w;&#125;e[N*20];int head[N&lt;&lt;4],cnt;long long inf;int n,m,s;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;int tin[N&lt;&lt;4],tout[N&lt;&lt;4],temp;long long dis[N&lt;&lt;4];void build(int k,int l,int r)&#123; if(l==r)&#123; tin[k]=tout[k]=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tin[k]=++temp;tout[k]=++temp; add(tout[k&lt;&lt;1],tout[k],0); add(tout[k&lt;&lt;1|1],tout[k],0); add(tin[k],tin[k&lt;&lt;1],0); add(tin[k],tin[k&lt;&lt;1|1],0);&#125;void update1(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(u,tin[k],w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update1(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update1(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;void update2(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(tout[k],u,w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update2(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update2(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;struct node&#123; int u; long long d; bool operator&lt;(const node&amp;h)const&#123;return d&gt;h.d;&#125;;&#125;;void dij()&#123; memset(dis,0x3f,sizeof(dis)); inf=dis[1]; priority_queue&lt;node&gt; q; dis[s]=0; q.push((node)&#123;s,0&#125;); while(!q.empty())&#123; node now=q.top(); int u=now.u; long long d=now.d; q.pop(); if(d!=dis[u])continue; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),s=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int opt=read(); if(opt==1)&#123; int x=read(),y=read(),z=read(); add(x,y,z); &#125; else if(opt==2)&#123; int u=read(),l=read(),r=read(),w=read(); update1(1,1,n,l,r,u,w); &#125; else&#123; int u=read(),l=read(),r=read(),w=read(); update2(1,1,n,l,r,u,w); &#125; &#125; dij(); for(int i=1;i&lt;=n;i++)&#123; if(dis[i]!=inf)&#123; printf(\"%I64d \",dis[i]); &#125; else printf(\"-1 \"); &#125; return 0;&#125; 以上、","categories":[{"name":"Solution","slug":"Solution","permalink":"http://yoursite.com/categories/Solution/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"},{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"Hello World","slug":"Hello-World","date":"2019-02-05T22:40:23.000Z","updated":"2019-02-05T22:51:00.340Z","comments":true,"path":"2019/02/06/Hello-World/","link":"","permalink":"http://yoursite.com/2019/02/06/Hello-World/","excerpt":"","text":"Hello World 咕到春节才写第一篇并且上线 语文差点垫底所以文笔较差多见谅(…以后估计也不会有什么长进 该博客大多是和OI相关的题解/游记/学习笔记/…有关的 也会发部分个人的总结之类的(?本质问号bot 12345#include&lt;cstdio&gt;int main()&#123; puts(\"Hello World\"); return 0;&#125; 以上、","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/tags/Diary/"}]}]}