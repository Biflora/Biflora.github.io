<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[USACO18] Talent Show]]></title>
    <url>%2F2019%2F02%2F07%2FTalent-Show%2F</url>
    <content type="text"><![CDATA[Luogu P4377 $Description$给定$n​$个物品和一个$V​$,每个物品有一个$t_i​$和$w_i​$属性请选出一部分物品使 $\frac{\sum t_i}{\sum w_i}​$最大,且$\sum w_i \ge V​$ $Solution$水题,0/1分数规划的基础上加上一个小限制根据原式子 $\sum t_i-\sum w_i*mid>0$可以用01背包检查二分出的$mid$的合法性即$f[V]>0$注意开long long(偷懒就define int long long了) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define int long long const int V=10010;const int N=400;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int f[V],w[N],t[N];int n,v,inf;bool check(int x)&#123; memset(f,128,sizeof(f)); inf=f[1];f[0]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=v;j&gt;=0;j--)&#123; if(f[j]!=inf)&#123; f[min(v,j+w[i])]=max(f[min(v,j+w[i])],f[j]+t[i]-w[i]*x); &#125; &#125; &#125; return f[v]&gt;=0;&#125;signed main()&#123; n=read(),v=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read();t[i]=read(); t[i]*=1000; &#125; int l=0,r=1000000; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1; else r=mid-1; &#125; printf("%lld",l-1); return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
        <tag>分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015] Pustynia]]></title>
    <url>%2F2019%2F02%2F07%2FPOI2015-Pustynia%2F</url>
    <content type="text"><![CDATA[Luogu P3588 $Description$给定一个长度为$n$的$a$正整数序列,$a_imax=1e9$,并给出$s$个数列中已知的数.现给出$m$条信息,信息内容如下:给定$l,r,k$,接下来给出$k$个数要保证这$k$个数大于剩下$r-l-k+1$个数若无解,则输出NIE,否则,输出TAK,并给出序列$a$ $Solution$这道题的弱化版SCOI 2011 糖果弱化版为差分约束裸题,也可以用缩点+拓扑排序解决题中每一个$a_i&lt;a_j$的约束条件也可以化成拓扑排序找环以求解给出区间的$k$个点把该区间分成$k+1$个子区间因为给出的$pos_i$单调递增,区间连续那就可以用线段树优化建边了判无解有三种情况: 该节点已知但该点可取最小值大于该值 该节点可取最小值超出范围 存在环 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;const int N=500100;const int INF=1e9;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N&lt;&lt;3];int head[N&lt;&lt;2],cnt;int deg[N&lt;&lt;2],a[N&lt;&lt;2],dis[N&lt;&lt;2];int n,m,s,temp;bool vis[N&lt;&lt;2];void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].w=w; deg[v]++;&#125;int t[N&lt;&lt;2];void build(int k,int l,int r)&#123; if(l==r)&#123; t[k]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); t[k]=++temp; add(t[k&lt;&lt;1],t[k],0); add(t[k&lt;&lt;1|1],t[k],0);&#125;void update(int k,int l,int r,int L,int R,int u)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(t[k],u,0); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)update(k&lt;&lt;1,l,mid,L,R,u); if(mid&lt;R)update(k&lt;&lt;1|1,mid+1,r,L,R,u);&#125;void ins()&#123; n=read(),s=read(),m=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=s;i++)&#123; int pos=read(),x=read(); a[pos]=dis[pos]=x; &#125; for(int i=1;i&lt;=m;i++)&#123; int l=read(),r=read(),k=read(),x; int pre=l; ++temp; for(int j=1;j&lt;=k;j++)&#123; x=read(); add(temp,x,1); if(x&gt;pre)update(1,1,n,pre,x-1,temp); pre=x+1; &#125; if(x&lt;r)update(1,1,n,x+1,r,temp); &#125;&#125;void topo()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++)&#123; if(!dis[i])dis[i]=1; if(!deg[i])q.push(i); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); vis[u]=true; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; dis[v]=max(dis[v],dis[u]+w); if(!--deg[v])q.push(v); &#125; &#125;&#125;int main()&#123; ins();// for(int i=1;i&lt;=n;i++)&#123;// cout&lt;&lt;deg[i]&lt;&lt;" ";// &#125; topo();// for(int i=1;i&lt;=n;i++)&#123;// printf("%d ",dis[i]);// &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]||dis[i]&gt;INF||(dis[i]&gt;a[i]&amp;&amp;a[i]))&#123; cout&lt;&lt;"NIE"&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;"TAK"&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; printf("%d ",dis[i]); &#125; return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flows]]></title>
    <url>%2F2019%2F02%2F06%2FFlows%2F</url>
    <content type="text"><![CDATA[网络流总结 $1. \ Code$ 最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//dinic#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N*4];int head[N],cnt=-1;int n,m,s,t,sum;int cur[N],deep[N];int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void ins()&#123; &#125;bool bfs()&#123; memset(deep,0,sizeof(deep)); queue&lt;int&gt; q; q.push(s); deep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(!deep[v]&amp;&amp;w)&#123; deep[v]=deep[u]+1; q.push(v); &#125; &#125; &#125; if(deep[t])return true; return false;&#125;int dfs(int u,int value)&#123; if(u==t)return value; for(int&amp; i=cur[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(deep[v]==deep[u]+1&amp;&amp;w)&#123; int now=dfs(v,min(value,w)); if(now)&#123; e[i].w-=now; e[i^1].w+=now; return now; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int ans=0; while(bfs())&#123; for(int i=s;i&lt;=t;i++)&#123; cur[i]=head[i]; &#125; while(int d=dfs(s,INF))ans+=d; &#125; return ans;&#125;int main()&#123; memset(head,-1,sizeof(head)); ins(); return 0;&#125; 最小费用最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//minimum cost maximum flow#include&lt;bits/stdc++.h&gt;#define int long long #define INF 0x7fffffffconst int N=10010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w; int cost;&#125;e[N*10];int head[N],cnt=-1;int flow[N],dis[N],pre[N],las[N];int w[N];int ans1,ans2;bool vis[N];int n,s,t,p,m,f,q,k;void add(int u,int v,int w,int c)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].cost=c;&#125;void ins()&#123; &#125;bool spfa()&#123; queue&lt;int&gt; q; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(flow,0x3f,sizeof(flow)); q.push(s); vis[s]=true;dis[s]=0;pre[t]=-1; while(!q.empty())&#123; int u=q.front(); q.pop();vis[u]=false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w,c=e[i].cost; if(w&amp;&amp;dis[v]&gt;dis[u]+c)&#123; dis[v]=dis[u]+c; pre[v]=u; las[v]=i; flow[v]=min(flow[u],w); if(!vis[v])&#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]!=-1)return true; return false; &#125;void mcfc()&#123; while(spfa())&#123; int now=t; ans1+=flow[now]; ans2+=flow[now]*dis[now]; while(now!=s)&#123; e[las[now]].w-=flow[t]; e[las[now]^1].w+=flow[t]; now=pre[now]; &#125; &#125;&#125;signed main()&#123; return 0;&#125; $2. \ Problems$ Luogu P1231 教辅的组成若直接建图会导致一本书用多次,考虑将书拆成两个点,建超源超汇直接跑dinic即可 BZOJ1001&amp;&amp;Luogu P4001 狼抓小粉兔 根据最大流=最小割=对偶图最短路,根据题意无向图直接建双向边即可 Luogu P2057 SHOI2007 善意的投票先按同意不同意建出两个$S$和$T$不同的集合,直接根据是否是朋友连双向边即可,最小割=最大流 Luogu P3410 拍照经典的最大权闭合子图例题, $s$连正权点$v_i$,$t$连负权点$v_i$,边容量为$\left| w_v\right|$ 相关点连边$E${$u,v,inf$} 跑最小割,$ans=$$\sum w_i -​$最小割 若求方案,在残余网格图中瞎搞就行了 $\bigstar$ Luogu P3980 [NOI2008] 志愿者招募(!) 未完成…]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF786B Legacy]]></title>
    <url>%2F2019%2F02%2F06%2FCF786B%2F</url>
    <content type="text"><![CDATA[CF 786B Legacy $Description$ 有$n​$颗星球,$q​$种方案,$s​$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \lbrack l_i,r_i \rbrack$星球花费为$w_i$ 从$ \lbrack l_i,r_i \rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费 $ Solution $ 处理区间建边显然是不能直接暴力加边的 考虑建一个虚点使加的边数量变少,而处理区间问题很好用的线段树就可以用上了 如图所示,建两棵线段树,分别自顶向下加边和自下向顶加边,分别对应单点向区间加边和区间向单点加边 只要在建出的图上跑一遍$dij$就过了 注意点:点数有$n$+$2nlogn$,边数最多有$2nlogn$+$mlogn$,数组要开大(一人血书提醒$Code$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct edge&#123; int v,nxt,w;&#125;e[N*20];int head[N&lt;&lt;4],cnt;long long inf;int n,m,s;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;int tin[N&lt;&lt;4],tout[N&lt;&lt;4],temp;long long dis[N&lt;&lt;4];void build(int k,int l,int r)&#123; if(l==r)&#123; tin[k]=tout[k]=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tin[k]=++temp;tout[k]=++temp; add(tout[k&lt;&lt;1],tout[k],0); add(tout[k&lt;&lt;1|1],tout[k],0); add(tin[k],tin[k&lt;&lt;1],0); add(tin[k],tin[k&lt;&lt;1|1],0);&#125;void update1(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(u,tin[k],w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update1(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update1(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;void update2(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(tout[k],u,w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update2(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update2(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;struct node&#123; int u; long long d; bool operator&lt;(const node&amp;h)const&#123;return d&gt;h.d;&#125;;&#125;;void dij()&#123; memset(dis,0x3f,sizeof(dis)); inf=dis[1]; priority_queue&lt;node&gt; q; dis[s]=0; q.push((node)&#123;s,0&#125;); while(!q.empty())&#123; node now=q.top(); int u=now.u; long long d=now.d; q.pop(); if(d!=dis[u])continue; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),s=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int opt=read(); if(opt==1)&#123; int x=read(),y=read(),z=read(); add(x,y,z); &#125; else if(opt==2)&#123; int u=read(),l=read(),r=read(),w=read(); update1(1,1,n,l,r,u,w); &#125; else&#123; int u=read(),l=read(),r=read(),w=read(); update2(1,1,n,l,r,u,w); &#125; &#125; dij(); for(int i=1;i&lt;=n;i++)&#123; if(dis[i]!=inf)&#123; printf("%I64d ",dis[i]); &#125; else printf("-1 "); &#125; return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F06%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World 咕到春节才写第一篇并且上线 语文差点垫底所以文笔较差多见谅(…以后估计也不会有什么长进 该博客大多是和OI相关的题解/游记/学习笔记/…有关的 也会发部分个人的总结之类的(?本质问号bot 12345#include&lt;cstdio&gt;int main()&#123; puts("Hello World"); return 0;&#125; 以上、]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
</search>
