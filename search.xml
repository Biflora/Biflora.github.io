<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[花の咲いたカエル]]></title>
    <url>%2F2019%2F02%2F24%2F%E8%8A%B1%E3%81%AE%E5%92%B2%E3%81%84%E3%81%9F%E3%82%AB%E3%82%A8%E3%83%AB%2F</url>
    <content type="text"><![CDATA[[花の咲いたカエル] 原文链接如上,已获得译者转载许可,请勿未经译者许可转载 著者：n-buna 絵：あわしま 翻訳：歌音咲 校対：KUMO. 花の咲いたカエル 森の中の小さな井戸に一匹の小さなカエルが住んでいます。 森林中的一口小井里住着一只小青蛙。 カエルが井戸から出かけるたびに風に吹かれてお辞儀をします。 他绿色的脑袋上有一枝也是小小的花正在发芽，当他从井中外出时花朵便在风的吹拂下弯下去，像是在行礼。 いつ生えたのかは覚えていませんが、カエルはあまりそれを快く思っていません。 虽然并没有察觉到是什么时候开始发芽的，但是青蛙并不怎么觉得这是件愉快的事情。 カエルは普通に憧れていたのです。 因为青蛙向往着普通。 その年は、とてもとても寒い冬だったので、カエルは毎日、毎日毎日、井戸の中で寝ているだけでした。 那一年的冬天，由于非常非常寒冷，青蛙每天、每天都只是躲在井里睡觉。 ある日、寒いので外にも出られず、あまりにも暇なので、カエルは葉っぱのベッドで横になって考えていました。どうしてぼくの頭には花が生えているんだろう。 有一天，外面依旧很冷而无法外出，由于实在太无聊了，青蛙就在叶子床上躺下了思考着。为什么我的头上会有花在发芽呢。 ほかのカエル達にはそんなものはありません。みんな同じようにミドリの頭をしているだけです。カエルは考えれば考えるほどわからなくなって、ついには悲しくてポロリと涙をこぼし始めました。 其他的青蛙们都没有长这样的东西。大家都只是有着同样的绿色的脑袋罢了。青蛙越想越不能明白，终于他悲伤得开始啪嗒啪嗒地掉下眼泪。 カエルはふと井戸の水面に映っている自分のすがたを見ました。花が心なしかしおれて、いつもより小さく見えました。カエルはぼんやりと考えます。もしかすると、この花はぼくがかなしくなるほど小さくなるのかもしれない。どんどん悲しくなっていけば、最後はあさがおみたいにしおれて、枯れて無くなってしまうのかもしれない！ 青蛙忽然看到了自己在井中水面上的倒影。花朵像是枯萎了似的，比任何时候看上去都要小。青蛙又心不在焉地思考起来。说不定，也许我越悲伤，这朵花就会变得越小。如果我不断地悲伤下去，也许最后花朵就会像牵牛花那样枯萎然后消失！ カエルはもっと、もっと、悲しくなろうとしましたが、一体どうすればいいかわかりません。ついには考えるのに疲れて、葉っぱのベッドに横になり眠ってしまいました。 青蛙想着让自己变得更加、更加悲伤，却不知到底应该怎么做，想着想着，终于他十分疲倦，就躺在叶子床上睡着了。 眠る時もずっと、花のことを考えていました。 连睡着的时候，他还一直在想着花朵的事。 春が訪れました。 春已降至。 カエルは目を覚まして外に出ると、森はすっかり春もよう。 青蛙醒了过来，他跳到井外一看，森林里已完全是一片春意盎然的景象。 あたたかい日差しがそこらじゅうに射しています。 温暖的阳光照耀着每一个角落。 カエルは遠くまで出かけようと思いました。 青蛙想要外出到遥远的地方去。 森の外にはきっとたくさんのかなしいことが転がっているに違いない、そう考えたのです。 森林的外面一定有着许许多多悲伤的事物吧，他这么想着。 カエルは小さなミドリのお弁当を持って、井戸の中の自分の家に向かって、またねと小さく手を振りました。 青蛙拿着小小的绿色的便当盒，朝着自己井里的家一边说着「再见」一边小小地挥着手。 「世界で一番かなしいことを探しに行こう」 「我要去探寻世界上最悲伤的事物」 森の外に向かって歩き始めると、春風に吹かれて頭の小さな小さな花がそよそよと揺れました。 他开始向着森林外走去，春风拂过，他头顶小小的小小的花朵就微微地摇动起来。 カエルは少しうきうきして、笑っていました。 青蛙也稍稍有些愉快地笑了起来。 森を歩いていると、ウサギの親子が散歩をしていました。 他在森林中走着，遇见了正在散步的兔子母子。 カエルはこんにちは、と声をかけると、こう尋ねました。 「你们好」青蛙对他们这样地打了招呼，然后向他们打听道。 「ウサギさん、世界で一番かなしいことを知らないかい？」 「兔子桑，你知道世界上最悲伤的事物是什么吗？」 ウサギのお母さんはカエルの頭の小さな花を見て、少しびっくりしていましたが、こう答えました。 兔子妈妈看了看青蛙脑袋上小小的花朵，稍稍地惊愕了一下，然后这样回答道。 「人参が食べられなくなることが一番かなしいよ」 「不能吃到胡萝卜就是最悲伤的哟」 カエルは自分が人参を食べられなくなったときのことを想像してみましたが、あまり悲しくありません。うん、とうなりながら、首をかしげました。カエルは人参があまり好きではないのです。 青蛙试着想象了一下自己吃不到胡萝卜的情景，却并不觉得太悲伤。嗯，他一边想着是否恰当，一边不相信地歪着头。青蛙并不怎么喜欢胡萝卜。 「ウサギのお母さん、ぼくはどうやったらかなしいことが見つけられるかな？」 「兔子妈妈，我要怎么做才能寻找到悲伤的事物呢？」 カエルがそう聞くと、ウサギのお母さんは「自分の好きな食べものがなくなったときのことを考えればいいのよ」と言います。 青蛙这样问道，兔子妈妈说：「只要想象自己喜欢的食物消失时的情景就可以了哟。」 カエルは自分のお弁当に入れたおかずたちが食べられなくなることを想像してしましたが、あまり悲しくはありませんでした。 青蛙想象了自己装入便当的美食们都没得吃的情景，然而他并没有觉得太悲伤。 「ウサギさんありがとう。ぼくは別のところへ探しに行きます」 「谢谢兔子桑。我去别的地方寻找了。」 ウサギの親子は不思議そうな顔をしていましたが、カエルは気にせずお礼を言いました。 兔子母子以不可思议的神情望着他，青蛙却并没有察觉到地表达了谢意。 別れ際に、ウサギの子供がカエルの頭を指差して、「かわいいお花だね」と言いました。 分别之时，小兔子指着青蛙的脑袋，说：「好可爱的花呢。」 カエルはどこがかわいいのか、あまりわかりませんでしたが、けろりと返事をしてそのまま歩き始めました。 虽然青蛙并不明白哪里可爱，但是他仍然满不在乎地回应着，继续行走起来。 次の日、森を抜けるとそこは原っぱでした。 第二天，他穿过了森林，到达了原野。 カエルは原っぱが好きです。花がたくさん咲いているので、自分の頭に花が咲いていることに気づかれにくいだろうと思うからです。 青蛙喜欢原野。因为他想，原野上开着那么多的花，自己头上开着花就不容易被察觉到了。 カエルは草をかき分けて、ずんずん進んでいきました。 青蛙拨开草丛，快步向前进发着。 少し歩いた先で、アリとカマキリが喧嘩していました。 步行的稍前方，蚂蚁和螳螂正在大吵大嚷。 カエルがどうしたのかと聞きました。アリは「聞いてくれよ。こいつはおれのアゴより自分のカマの方がかっこいいと言うんだ」と怒りながら言いました。 青蛙想要一探究竟地上前询问，蚂蚁生气地说：「请听听哟。这小子说比起我的下巴来，他的镰刀更加帅气。」 カマキリは「こいつがオレのカマより自分のアゴの方が強いというんだ」とこれもまた怒りながら言いました。 螳螂也非常生气地说：「这小子说他的下巴比我的镰刀更加坚韧。」 カエルはアリの黒く光るアゴと、カマキリのギザギザのするどいカマを交互に見比べました。 青蛙将蚂蚁黑亮地闪着光的下巴，与螳螂锯齿状的锋利的镰刀相互地比较着。 「君のアゴは太陽に照らされ輝いてカッコいいし、君のカマはとてもするどくてこの草はらの何でも切りさいてしまえそうだよ」 「你的下巴在太阳的照耀下更加闪亮帅气了；你的镰刀非常锋利，就好像这草原上的任何东西都能切碎呢。」 アリとカマキリは自分の好きなところが褒められたので少し得意げになって、そうかそうかと笑いました。 蚂蚁和螳螂各自喜爱的地方都得到了赞美，他们稍稍地得意起来，原来如此啊是这样呢地笑了起来。 それから二匹してお互いのアゴやカマを、ここが黒いだの、ここがするどいだのを褒め合い出しました。カエルは少し居づらくなったのですが、勇気を出して「アリくん、カマキリくん、世界で一番かなしいことって何かな？」と聞きました。 在这之后他们两个便互相夸奖起对方黑亮的下巴和锋利的镰刀来。青蛙稍稍觉得有点如坐针毡，于是他鼓起勇气问道：「蚂蚁君，螳螂君，世界上最悲伤的事物是什么呐？」 アリとカマキリは顔を見合わせて、「それはもちろん、おれのアゴがカッコよくなくなることさ」「それはもちろん、オレのカマが強くなくなることだよ」と交互に言いました。それから二匹して「つまりお前のその花がなくなっちゃうようなもんさ」と言いました。 蚂蚁和螳螂面面相觑，他们交替说：「那当然是，我的下巴变得不帅气啦。」「那当然是，我的镰刀变得不坚韧了哟。」然后，他们两个一齐说道：「总之就是像你的那花朵消失了那样呢。」 カエルはすっかり花のことを忘れて話していたので、ミドリの顔を少し赤くしました。それから自分の頭を見上げて、その花がなくなってしまったときのことを想像しましたが、むしろ嬉しいばかりです。 青蛙本来已经完全忘记了花朵的事情，如今又被说起，他绿色的脸稍稍有些红了。接着，他仰望着自己的脑袋，想象了一下那花朵消失时的情景，倒不如说开心了起来。 「アリくん、カマキリくん、他のかなしいことを知らないかい」カエルが言うと、カマキリのお腹がぐうと鳴って「お腹が減ってしまうことかな」と恥ずかしいそうに頭を掻きました。 「蚂蚁君，螳螂君，你们知道其他悲伤的事物吗？」青蛙问道，此时螳螂的肚子咕地叫了起来。「我的肚子饿了呢。」他有些不好意思地挠了挠头。 カエルは思わず笑いました。そして自分が食べものを持っていたことを思い出して、お弁当をとりだしました。 青蛙不由自主地笑了起来。接着他想起了自己带了食物，于是他拿出了自己的便当。 「お弁当があるから、一緒に食べよう」と誘いました。 「我带了便当，我们一起来吃吧！」他这么邀请道。 アリとカマキリは喜んで、それから葉っぱに座って三匹はご飯をたべました。 蚂蚁和螳螂十分欣喜，于是他们三个就在叶子上坐下吃起饭来。 食べ終わってから少しして、友達が出来たようでなごりおしかったのですが、カエルはもうそろそろ行くよと言いました。 吃完后不久，虽然朋友们表现出十分依依不舍的样子，但是青蛙告诉他们他已经差不多要继续前行了。 二匹がまた来いよと言います。カエルは少し嬉しくなって、でも悲しくなって、それから「またね」と手を振って、歩き出しました。 蚂蚁和螳螂说着还要再来哟。青蛙稍稍有些高兴，却又有些悲伤，于是他挥手说着再见了，迈开了脚步。 頭の上の花が少ししおれている気がしましたが、カエルはあまり嬉しくありませんでした。 青蛙察觉到他脑袋上的花朵稍稍有些凋谢了，但他却不怎么高兴得起来了。 ちょっとだけ歩いたところで、後ろから二匹の声が聞こえました。「あいつの花もカッコよかったなぁと」と話しているようでした。 他稍微走了一段路之后，从后方传来那两个人的声音。「那小子的花也很帅气呢！」他们像是这样说着。 原っぱを抜けた先で、カエルは石にすわって休むことにしました。 青蛙穿过了原野，然后在一块石头上坐下来休息。 空はもう夕暮れです。 天空已经被夕暮笼罩。 夕焼けを見ながら昔を思い出しました。青蛙一边望着天际的晚霞，一边回忆起过去的事。 おたまじゃくしの頃のことはあまり覚えていませんが、だんだんしっぽがなくなり始めたときには、もう芽は出ていました。蝌蚪时期的事情已经想不起来了，从尾巴渐渐消失的时候开始，芽就已经长出来了。 それからいつの間にか芽は大きくなり、つぼみをつけ、花を咲かせたのです。在那之后不知不觉芽就长大了，长出了花苞，最后花朵绽放了。 アリやカマキリのように仲良くケンカしたり、遊んだりする友だちは昔はいましたが、あたまに花がさいた自分をみて気味悪がったのか、皆いなくなってしまいました。曾经有过像蚂蚁和螳螂那样能够亲密地吵嚷、嬉戏的朋友们，但他们看到头上开出花的自己都感到毛骨悚然，于是就全部离开了。 カエルはそれに怒ったりもせず、ただしょうがないとも思っていました。而青蛙并不觉得生气，只是感到没办法。 赤い夕陽に照らされながら、小さな花はそよそよとそよいでいます。小小的花朵一边被赤红的夕阳照耀着，一边微微地摇动着。 カエルは普通に憧れていました。青蛙向往着普通。 夜になりました。夜幕降临。 たどり着いた沼を歩いていると、コケむした石が、ぼうっと光っていました。カエルはさっきから少し寂しかったので、石にも話しかけたい気持ちになって「あの、すみません。世界で一番かなしいことを知りませんか？」と尋ねました。在到达的沼泽上走着，覆盖着青苔的石头发出朦胧的光亮。青蛙从刚开始就感到有些寂寞，于是他都想跟石头说话了。「那个，打扰了。你知道世界上最悲伤的事物吗？」他这么询问道。 石はじっとカエルを見ています。そのまま30秒ほど経ったとき、「このからだがピカピカ光らなくなるのが、一番かなしいことだよ」と、小さな声で呟きました。石头凝视着青蛙。就那样持续了三十秒以后，小小的声音嘟囔着：「那么变得无法闪闪发光的话，就是最悲伤的事情了哟。」 カエルは返事が返ってきたことにおどろきましたが、きっとこのコケむした石なら、何百年もここにいるうちに悲しいことをたくさん見てきたに違いない、と思って話し続けました。虽然青蛙对石头答复了他感到十分惊讶，但他想，如果是这块覆盖着青苔的石头的话，在这儿伫立了几百年，一定见到过许许多多悲伤的事物，于是他继续说了下去。 でも、ぼくは体が光らないから。なかなかそれが想像できません」「但是，我的身体不发光，很难想象这件事呢。」 実際、カエルは自分のからだが光ったり、消えたりするのを想像しましたが、あまり素敵なことに思えませんでしたし、それがなくなったとしても悲しくはないだろうと思いました。实际上，青蛙想象了自己的身体发出光、然后光亮消失的情景。他觉得这并不是一件美好的事，但是他并不会发光，所以他也不觉得悲伤了。 「お石さん、ぼくにとっての、世界で一番かなしいことってなんでしょうか？」「石头先生，我应该怎么做，才能知道世界上最悲伤的事物是什么呢？」 カエルは続けてそう聞くと、石は「それは私にはわからない」と言いました。青蛙继续这样打听道。石头说：「这我也不知道。」 「ただ、きみも私も、いつか命のあるものはみんな、そのあかりが消えて、花が枯れるみたいにいなくなってしまうのだ。それがかなしくないなら、きっと他には何もないだろうなぁ」「只是，你也好我也好，有一天生命的光亮都会消失殆尽，就像花儿枯萎了那样。如果这都不算悲伤的话，一定就没有其他悲伤的事物了吧。」 カエルは自分の命のあかりが消えることを想像して、想像して、でもあまり実感が湧きません。だから今まで出会った、ウサギの親子、アリや、カマキリや、小さいころ遊んだ友だちの命のあかりが消えて、ずっといなくなってしまうことを想像しました。青蛙想象着、想象着自己生命的光亮消失殆尽的景象，心中却几乎涌现不出实感。所以他想象起了至今为止遇到过的兔子母子、蚂蚁、螳螂、还有小时候一同玩耍的朋友们的生命之光消逝、不复存在的情景。 するとびっくりするほどに涙が出るのです。然后他吃了一惊，不禁落下了眼泪。 ぬぐってもぬぐっても雨のように止まらないので、カエルはついに、とてもかなしいことを見つけしまったと思いました。无论是怎样地擦拭，眼泪还是像下雨那样无法停止。于是青蛙觉得他已经找到了非常悲伤的事物。 カエルは慌てて沼の水に映った自分を見てみると、それでも頭の花はかわらずそこにありましたが、また少ししおれて小さくなっている気がしました。青蛙慌忙看向自己在沼泽水面上的倒影，即使这样脑袋上的花朵也依旧不变地在那儿，不过青蛙察觉到花朵又稍稍枯萎了些，变小了。 カエルは顔をもう一度ぬぐうと、「お石さん、ありがとうございました。とてもかなしいことを教えていただいて」と言いました。青蛙再一次拭去了脸上的泪，他说：「石头先生，感谢您，教授给我这么悲伤的事物。」 そのまま数秒ほど待ったのですが、返事がないうえに、ぼうっとした光がだんだんと消えていきます。石の根元まで近づいてみると、光っていたものの正体が、とても年老いて大きくなったキノコだったことに気付きました。就那样等待了数秒钟之后，也没有回答，并且朦胧的光亮逐渐消失了。靠近石头的根部一看，这才发觉发光物的真面目是一只年纪很老的大蘑菇。 カエルは少し不思議な気持ちのまま、もう一度お礼を言って歩き出しました。少し歩いて、さっきのキノコのそれが、命のあかりが消えた瞬間だということに気付いたのです。青蛙稍稍觉得有些不可思议，于是他再一次道谢然后出发了。刚走了几步，刚才蘑菇的生命之光消逝瞬间的情景又浮现在眼前。 カエルはまた少し涙が出ましたが、歩き続けました。青蛙又落下了眼泪，但他仍继续前行。 カエルはそれでもまだ、普通に憧れていました。即使如此，青蛙也仍然向往着普通。 次の日も次の日も、その次の日もカエルは歩き続けました。之后的一天又一天，青蛙继续前行。 山を越え、谷を越え、川を越え、そこでいろいろな生き物に出会ったのですが、なかなかキノコに教えてもらった時ほどに悲しいことは見つかりません。他越过了高山、越过了谷地、越过了河流，在那里遇到了许许多多的动物，却并没有寻找到像蘑菇教授给他的时候那么悲伤的事物。 それどころか、みんな口々にカエルの頭の花を褒めるので、カエルはずっと不思議な気持ちでいました。然而无论在哪里，大家都一齐赞美了青蛙脑袋上的花，青蛙也一直觉得十分不可思议。 今までじゃまなものに感じていた花が、なんだか自分のからだの一部みたいに感じ始めたのです。至今为止感到烦人的那朵花，也开始觉得像是成为了自己身体的一部分。 そしてある日、砂漠に通りかかった時、カエルは自分の頭の花がしおれて首を曲げ始めていることに気付きました。然后有一天，在穿越沙漠的时候，青蛙察觉到自己脑袋上的花朵凋谢了，垂下了头。 その時のカエルはどうしたでしょうか。那时的青蛙是怎样的反应呢。 喜ぶでもなく、悲しむでもなく、ただぼうっと花を触っていました。既没有欣喜若狂，也没有黯然失色，只是出神地触碰着那朵花。 また夜になって、大きな満月が砂漠に昇り始めました。夜幕又降临了，一轮硕大的满月开始在沙漠上空升起。 カエルはオアシスの木の下で、座って星を眺めています。青蛙在绿洲的树木下坐着，眺望着星空。 あのキノコの言うように、命のあかりが消えることがとても悲しいことだとしたら、みんなに訪れるそれはぼくにもやってくる。その時、僕が想像したときと同じように、悲しんでくれる人がぼくにはいるだろうか、とそればかり考えていました。他只是在思考着这些事情：正如那蘑菇所说，生命之光消失殆尽这件无比悲伤的事情，无论如何都会降临到大家的身上，连我也不例外。当我想象的同时，大概也就经历了那些人所要承受的悲伤吧。 カエルには、花がしおれて枯れそうなことなんか、もうどうでも良かったのです。对于青蛙来说，花儿凋谢枯萎这样的事情，无论怎样都已经无所谓了。 その次の次の、次の日、花は枯れて小さな種を残しました。カエルは手にとって、じっとそれをながめると、やがて頭のうえにそっと置きました。过了一天又一天，花朵枯萎，只剩下了一粒小小的种子。青蛙将它拿到手中，久久地凝视着，最终小心翼翼地将它置于脑袋上。 カエルはもう、普通に憧れていませんでした。青蛙已经，不再向往着普通了。 砂漠を抜けると、海が見えてきました。青蛙穿过了沙漠，见到了大海。 カエルは海を知っていました。とても大きな井戸のことです。青蛙知道海是什么。就是，一口非常大的井。 そのほとりにこれまた小さな井戸があったので、カエルはその二つをよく見比べてながら、小さな井戸にぴょん、と飛び込みました。在海边也有一口这样小小的井，青蛙想要好好地比较一下这两口井，于是他轻快地一跃而入。 そしてカエルが底に着いたことで飛び散った水が、カエルの頭を濡らしたとき、小さな芽が一つ出ました。之后青蛙到达了井底，溅起了飞散的水花将他的脑袋濡湿，这时脑袋上长出了小小的芽。 カエルは水面に映った自分を見て、一声鳴いて笑いました。青蛙看到了自己在水面上的倒影，不禁叫了一声，笑了起来。 「結局森の中と変わらないじゃないか」「结局和在森林里相比不也没怎么改变嘛。」 カエルはこの井戸の底で、何か始めようと思っていました。青蛙在这个井底想要开始做些什么。 葉っぱの服屋さんとか、お弁当屋さんとか、出来るなら小さな花屋さんとか。叶子制成的衣服店店主、便当店店主，如果可以的话也可以做小小的花店店主。 井戸の底から見える空はとても青く、まるで海がもう一つあるみたいでした。从井底看到的天空无比蔚蓝，恍若一片广阔的大海。 海のそばの小さな井戸に一匹の小さなカエルが住んでいます。海边的一口小井里住着一只小青蛙。 ミドリの頭にはこれまた小さな花が一本生えていて、カエルが井戸から出かけるたびに風に吹かれてお辞儀をします。他绿色的脑袋上有一枝也是小小的花正在发芽，当他从井中外出时花朵便在风的吹拂下弯下去，像是在行礼。 いつ花が咲いたのかは覚えていませんが、カエルはそれを少しだけ誇りに思っています。虽然没有察觉到花朵是何时绽放的，但青蛙只是稍稍觉得有些骄傲。 その井戸の底には小さな花屋が開かれていて、そこにはいつも誰かが訪れて、世間話をしたり、花を買っていったりします。他在这口井里开着一家小小的花店，在那里无论谁来造访，总会一边和青蛙聊着天，一边买花。 カエルはもう普通に憧れたりはしません。青蛙已经不再向往着普通。 それから、ずっとそこで暮らしています。从那以后，他就一直在那里生活着。 【終わり】]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2010]阅读理解]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TJOI2010]阅读理解 $Description$给出$n$篇文章,每篇文章有$l$个单词,再给出$m$个单词,求出这$m$个词在哪几篇文章中出现过 对于100%的数据,$n\le 1000,m\le 10000$ $Solution$本来开个map直接随便草过去了但是这是字典树(Trie)的裸题就不偷懒了Trie很巧妙地把不同的具有公共前缀的单词建在同一条链上这样查询的复杂度就会低很多就是空间有点大,还算错了好几次(菜那么这题就很简单了直接建出一棵Trie标记每个单词出现的文章查询的时候遍历一下就可以了 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define N 100010using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;char s[30];int trie[1000010][26],n,cnt,rt,m;bool vis[1001][1000001];void ins(char *s,int root,int x)&#123; for(int i=0;s[i];i++)&#123; int k=s[i]-'a'; if(!trie[root][k])trie[root][k]=++cnt; root=trie[root][k]; &#125; vis[x][root]=true;&#125;void check(char *s,int root)&#123; bool flag=false; for(int i=0;s[i];i++)&#123; int k=s[i]-'a'; if(!trie[root][k])&#123; flag=true; break; &#125; root=trie[root][k]; &#125; if(!flag)&#123; for(int i=1;i&lt;=n;i++)&#123; if(vis[i][root])&#123; printf("%d ",i); &#125; &#125; &#125; cout&lt;&lt;endl;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; int l=read(); for(int j=1;j&lt;=l;j++)&#123; cin&gt;&gt;s; ins(s,rt,i); &#125; &#125; m=read(); for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;s; check(s,rt); &#125; return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2014]方伯伯运椰子]]></title>
    <url>%2F2019%2F02%2F23%2F%5BSCOI2014%5D%E6%96%B9%E4%BC%AF%E4%BC%AF%E8%BF%90%E6%A4%B0%E5%AD%90%2F</url>
    <content type="text"><![CDATA[[SCOI2014]方伯伯运椰子 $Description$给出$n+2$个点,$m$条边,每条边用$E$={$u,v,a,b,c,d$}表示,即$u$到$v$有一条容量为$c$的边,每单位运输量需要$d$的费用,压缩一次容量需要$a$的费用,扩容一次需要$b$的费用。 要保证每条边满负荷且总交通量(流量)不变,设调整前费用为$X$,调整之后的费用为$Y$,进行了$k$次调整,求$(X-Y)/k$的最大值 $Solution$看到式子可以很容易看出是一个分数规划的模型,考虑调整比率 $mid\times k-(X-Y)\ge 0$ 考虑如何判断上述式子是否成立第一个想到费用流,考虑建图$X-Y$可以看作$\Delta cost$那么考虑扩容和压缩如何处理扩容很显然费用即$b+d$那么压缩则应该是建$v$到$u$费用为$a-d$,且要满足容量$c&gt;0$这样就可以处理出$\Delta cost$因为此时边权为扩容or压缩一次产生的$\Delta cost’$,那么对于图中每一个环都应该满足环上点数$n$都应该满足 $ans\times n'-\Delta cost' \ge 0$ 这时$k$就是环上的点数$n’$了那么就可以知道,当$mid\ge ans$时 $mid\times n'-\Delta cost' \ge 0$ 反之 $mid\times n’-\Delta cost’&lt;0 $ 说明当图上存在负环时仍有更优解那么就可以直接用spfa判负环去判断$mid$的合法性了 $Code$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define eps 1e-3#define N 5010#define INF 0x7fffffffusing namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N&lt;&lt;1];int head[N],cnt,n,m;bool vis[N],flag;double dis[N];void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;bool spfa(int u,double mid)&#123; vis[u]=true; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w+mid)&#123; dis[v]=dis[u]+w+mid; if(vis[v])return true; if(spfa(v,mid))return true; &#125; &#125; vis[u]=false; return false;&#125;bool check(double mid)&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); flag=false; for(int i=1;i&lt;=n;i++)&#123; if(spfa(i,mid))return true; &#125; return false;&#125;int main()&#123; n=read()+2,m=read(); for(int i=1;i&lt;=m;i++)&#123; int u=read(),v=read(),a=read(),b=read(),c=read(),d=read(); if(c)add(v,u,a-d); add(u,v,b+d); &#125; double l=0.00,r=1000000000.00,mid; while(r-l&gt;=eps)&#123; mid=(l+r)/2; if(check(mid))l=mid; else r=mid; &#125; printf("%.2lf",l); return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>分数规划</tag>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI 2017] 新生舞会]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%96%B0%E7%94%9F%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[[SDOI 2017] 新生舞会 $Description$给定$n$个男生,$n$个女生,每一个男生对应每一个女生都有一个$a_{i,j}$同时每一个男生对应每一个女生有一个$b_{i,j}$令$C=\frac{\sum a_i}{\sum b_i}$,试求出$C$最大值 $Solution$化简该式子 $\sum a_i-C*\sum b_i=0$ 照样二分一个$mid$,因为给出一张二分图,所以尝试用费用流来判$mid​$的合法性考虑如何建图建源汇,源点连男生,男生连女生,女生连汇点,边的容量均为1考虑费用的分配既然要满足 $\sum a_i-mid*\sum b_i\ge0$ 那不妨将男女之间连边的费用设为$a_{i,j}-mid\times b_{i,j}$这样跑一遍最大费用最大流,再试判断最大费用是否满足上式这题卡常(开了O2还是跑了800+ms $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;const double eps=1e-7;const int N=5005;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct node&#123; int v,nxt,w; double c;&#125;e[N&lt;&lt;2];int head[N&lt;&lt;1],cnt=-1;int flow[N&lt;&lt;1],pre[N&lt;&lt;1],las[N&lt;&lt;1];double dis[N&lt;&lt;1];bool vis[N];double a[101][101],b[101][101];int ans1,s,t,n,m;double ans2;void add(int u,int v,int w,double c)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].c=c; e[cnt].nxt=head[u]; head[u]=cnt; e[++cnt].v=u; e[cnt].w=0; e[cnt].c=-c; e[cnt].nxt=head[v]; head[v]=cnt;&#125;void clear()&#123; memset(head,-1,sizeof(head)); memset(pre,0,sizeof(pre)); memset(las,0,sizeof(las)); ans1=ans2=0; cnt=-1;&#125;bool spfa()&#123; queue&lt;int&gt; q; memset(dis,-0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(flow,0x3f,sizeof(flow)); q.push(s); vis[s]=true;dis[s]=0;pre[t]=-1; while(!q.empty())&#123; int u=q.front(); q.pop();vis[u]=false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; double c=e[i].c; if(w&amp;&amp;dis[v]&lt;dis[u]+c)&#123; dis[v]=dis[u]+c; pre[v]=u; las[v]=i; flow[v]=min(flow[u],w); if(!vis[v])&#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]!=-1)return true; return false; &#125;void mcmf()&#123; while(spfa())&#123; int now=t; ans2+=(double)flow[now]*dis[now]; while(now!=s)&#123; e[las[now]].w-=flow[t]; e[las[now]^1].w+=flow[t]; now=pre[now]; &#125; &#125;&#125;bool check(double x)&#123; clear(); for(int i=1;i&lt;=n;i++)add(s,i,1,0); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; add(i,j+n,1,-x*b[i][j]+a[i][j]); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; add(i+n,t,1,0); &#125; mcmf(); return ans2&gt;0;&#125;int main()&#123; n=read(); s=0,t=n*2+3; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;b[i][j]; &#125; &#125; double l=0,r=1e4; while(r-l&gt;=eps)&#123; double mid=(l+r)/2; if(check(mid))l=mid; else r=mid; &#125; printf("%.6lf",l); return 0;&#125; 以上、 ​​​]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>MCMF</tag>
        <tag>分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO18] Talent Show]]></title>
    <url>%2F2019%2F02%2F07%2FTalent-Show%2F</url>
    <content type="text"><![CDATA[Luogu P4377 $Description$给定$n​$个物品和一个$V​$,每个物品有一个$t_i​$和$w_i​$属性请选出一部分物品使 $\frac{\sum t_i}{\sum w_i}​$最大,且$\sum w_i \ge V​$ $Solution$水题,0/1分数规划的基础上加上一个小限制根据原式子 $\sum t_i-\sum w_i*mid>0$可以用01背包检查二分出的$mid$的合法性即$f[V]>0$注意开long long(偷懒就define int long long了) $Code$1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define int long long const int V=10010;const int N=400;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int f[V],w[N],t[N];int n,v,inf;bool check(int x)&#123; memset(f,128,sizeof(f)); inf=f[1];f[0]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=v;j&gt;=0;j--)&#123; if(f[j]!=inf)&#123; f[min(v,j+w[i])]=max(f[min(v,j+w[i])],f[j]+t[i]-w[i]*x); &#125; &#125; &#125; return f[v]&gt;=0;&#125;signed main()&#123; n=read(),v=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read();t[i]=read(); t[i]*=1000; &#125; int l=0,r=1000000; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1; else r=mid-1; &#125; printf("%lld",l-1); return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
        <tag>分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015] Pustynia]]></title>
    <url>%2F2019%2F02%2F07%2FPOI2015-Pustynia%2F</url>
    <content type="text"><![CDATA[Luogu P3588 $Description$给定一个长度为$n$的$a$正整数序列,$a_imax=1e9$,并给出$s$个数列中已知的数.现给出$m$条信息,信息内容如下:给定$l,r,k$,接下来给出$k$个数要保证这$k$个数大于剩下$r-l-k+1$个数若无解,则输出NIE,否则,输出TAK,并给出序列$a$ $Solution$这道题的弱化版SCOI 2011 糖果弱化版为差分约束裸题,也可以用缩点+拓扑排序解决题中每一个$a_i&lt;a_j$的约束条件也可以化成拓扑排序找环以求解给出区间的$k$个点把该区间分成$k+1$个子区间因为给出的$pos_i$单调递增,区间连续那就可以用线段树优化建边了判无解有三种情况: 该节点已知但该点可取最小值大于该值 该节点可取最小值超出范围 存在环 $Code$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;const int N=500100;const int INF=1e9;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N&lt;&lt;3];int head[N&lt;&lt;2],cnt;int deg[N&lt;&lt;2],a[N&lt;&lt;2],dis[N&lt;&lt;2];int n,m,s,temp;bool vis[N&lt;&lt;2];void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].w=w; deg[v]++;&#125;int t[N&lt;&lt;2];void build(int k,int l,int r)&#123; if(l==r)&#123; t[k]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); t[k]=++temp; add(t[k&lt;&lt;1],t[k],0); add(t[k&lt;&lt;1|1],t[k],0);&#125;void update(int k,int l,int r,int L,int R,int u)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(t[k],u,0); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)update(k&lt;&lt;1,l,mid,L,R,u); if(mid&lt;R)update(k&lt;&lt;1|1,mid+1,r,L,R,u);&#125;void ins()&#123; n=read(),s=read(),m=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=s;i++)&#123; int pos=read(),x=read(); a[pos]=dis[pos]=x; &#125; for(int i=1;i&lt;=m;i++)&#123; int l=read(),r=read(),k=read(),x; int pre=l; ++temp; for(int j=1;j&lt;=k;j++)&#123; x=read(); add(temp,x,1); if(x&gt;pre)update(1,1,n,pre,x-1,temp); pre=x+1; &#125; if(x&lt;r)update(1,1,n,x+1,r,temp); &#125;&#125;void topo()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++)&#123; if(!dis[i])dis[i]=1; if(!deg[i])q.push(i); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); vis[u]=true; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; dis[v]=max(dis[v],dis[u]+w); if(!--deg[v])q.push(v); &#125; &#125;&#125;int main()&#123; ins();// for(int i=1;i&lt;=n;i++)&#123;// cout&lt;&lt;deg[i]&lt;&lt;" ";// &#125; topo();// for(int i=1;i&lt;=n;i++)&#123;// printf("%d ",dis[i]);// &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]||dis[i]&gt;INF||(dis[i]&gt;a[i]&amp;&amp;a[i]))&#123; cout&lt;&lt;"NIE"&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;"TAK"&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; printf("%d ",dis[i]); &#125; return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flows]]></title>
    <url>%2F2019%2F02%2F06%2FFlows%2F</url>
    <content type="text"><![CDATA[网络流总结 $1. \ Code$ 最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//dinic#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w;&#125;e[N*4];int head[N],cnt=-1;int n,m,s,t,sum;int cur[N],deep[N];int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void ins()&#123; &#125;bool bfs()&#123; memset(deep,0,sizeof(deep)); queue&lt;int&gt; q; q.push(s); deep[s]=1; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(!deep[v]&amp;&amp;w)&#123; deep[v]=deep[u]+1; q.push(v); &#125; &#125; &#125; if(deep[t])return true; return false;&#125;int dfs(int u,int value)&#123; if(u==t)return value; for(int&amp; i=cur[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(deep[v]==deep[u]+1&amp;&amp;w)&#123; int now=dfs(v,min(value,w)); if(now)&#123; e[i].w-=now; e[i^1].w+=now; return now; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int ans=0; while(bfs())&#123; for(int i=s;i&lt;=t;i++)&#123; cur[i]=head[i]; &#125; while(int d=dfs(s,INF))ans+=d; &#125; return ans;&#125;int main()&#123; memset(head,-1,sizeof(head)); ins(); return 0;&#125; 最小费用最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//minimum cost maximum flow#include&lt;bits/stdc++.h&gt;#define int long long #define INF 0x7fffffffconst int N=10010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct node&#123; int v,nxt,w; int cost;&#125;e[N*10];int head[N],cnt=-1;int flow[N],dis[N],pre[N],las[N];int w[N];int ans1,ans2;bool vis[N];int n,s,t,p,m,f,q,k;void add(int u,int v,int w,int c)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; e[cnt].cost=c;&#125;void ins()&#123; &#125;bool spfa()&#123; queue&lt;int&gt; q; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(flow,0x3f,sizeof(flow)); q.push(s); vis[s]=true;dis[s]=0;pre[t]=-1; while(!q.empty())&#123; int u=q.front(); q.pop();vis[u]=false; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w,c=e[i].cost; if(w&amp;&amp;dis[v]&gt;dis[u]+c)&#123; dis[v]=dis[u]+c; pre[v]=u; las[v]=i; flow[v]=min(flow[u],w); if(!vis[v])&#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t]!=-1)return true; return false; &#125;void mcmf()&#123; while(spfa())&#123; int now=t; ans1+=flow[now]; ans2+=flow[now]*dis[now]; while(now!=s)&#123; e[las[now]].w-=flow[t]; e[las[now]^1].w+=flow[t]; now=pre[now]; &#125; &#125;&#125;signed main()&#123; return 0;&#125; $2. \ Problems$ Luogu P1231 教辅的组成若直接建图会导致一本书用多次,考虑将书拆成两个点,建超源超汇直接跑dinic即可 BZOJ1001&amp;&amp;Luogu P4001 狼抓小粉兔根据最大流=最小割=对偶图最短路,根据题意无向图直接建双向边即可 Luogu P2057 SHOI2007 善意的投票先按同意不同意建出两个$S$和$T$不同的集合,直接根据是否是朋友连双向边即可,最小割=最大流 Luogu P3410 拍照经典的最大权闭合子图例题, $s​$连正权点$v_i​$,$t​$连负权点$v_i​$,边容量为$\left| w_v\right|​$ 相关点连边$E​${$u,v,inf​$} 跑最小割,$ans=​$$\sum w_i -​$最小割 若求方案,在残余网格图中瞎搞就行了 Luogu P3980 [NOI2008] 志愿者招募(!) 题意大概如下: 有$n$天每天需要$a_i$个人,有$m$种志愿者,每种志愿者包含如下信息 每种志愿者可以从$s_i$天工作到$t_i$天,每个人价格为$c_i$元,人数无限制 考虑如何建图 题目的限制条件是第$i$天要至少有$a_i$个人 直接建图是不可取的,每天需要的人力不同 对于一个志愿者{$s_i,t_i,c_i$} 可以用一条边来表示其覆盖$s_i$到$t_i$的全部区域,费用为$c_i$ 考虑流量分配 源点连第一天流量为INF,汇点连$n+1$个点流量为INF 既然要满足志愿者可以连续工作且每天至少$a_i$人 那么不妨直接将最大流分配至INF 让每一天连下一天的流量为INF-$a_i$ 对于每种志愿者连一条边$E${$s_i,t_i+1,inf,c_i$} 连续工作的志愿者可以走相邻天数的边,即无费用的边 但又需要$a_i$的流量才能保证满流 这样就可以让志愿者填上去,就保证费用和人数限制的正确性了 Luogu P2774 方格取数问题典型的黑白染色建二分图,分奇点和偶点建二分图$s$连黑点,容量为点权,黑连白,容量INF,白连$t$,容量为点权假设全局都选求出全局和 再求出最小割答案即为全局和-最小割 Luogu P2944 地震损失题意:已确定几个点不割,求最少割几个点使图不连通因为是割点不是割边,所以要拆点已确定点:入点出点容量为inf未确定点:入点出点容量为1根据题意直接建图,对于一条道路建双向容量无限的边跑dinic即可]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF786B Legacy]]></title>
    <url>%2F2019%2F02%2F06%2FCF786B%2F</url>
    <content type="text"><![CDATA[CF 786B Legacy $Description$ 有$n​$颗星球,$q​$种方案,$s​$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \lbrack l_i,r_i \rbrack$星球花费为$w_i$ 从$ \lbrack l_i,r_i \rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费 $ Solution $ 处理区间建边显然是不能直接暴力加边的 考虑建一个虚点使加的边数量变少,而处理区间问题很好用的线段树就可以用上了 如图所示,建两棵线段树,分别自顶向下加边和自下向顶加边,分别对应单点向区间加边和区间向单点加边 只要在建出的图上跑一遍$dij$就过了 注意点:点数有$n$+$2nlogn$,边数最多有$2nlogn$+$mlogn$,数组要开大(一人血书提醒$Code$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct edge&#123; int v,nxt,w;&#125;e[N*20];int head[N&lt;&lt;4],cnt;long long inf;int n,m,s;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;int tin[N&lt;&lt;4],tout[N&lt;&lt;4],temp;long long dis[N&lt;&lt;4];void build(int k,int l,int r)&#123; if(l==r)&#123; tin[k]=tout[k]=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tin[k]=++temp;tout[k]=++temp; add(tout[k&lt;&lt;1],tout[k],0); add(tout[k&lt;&lt;1|1],tout[k],0); add(tin[k],tin[k&lt;&lt;1],0); add(tin[k],tin[k&lt;&lt;1|1],0);&#125;void update1(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(u,tin[k],w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update1(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update1(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;void update2(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(tout[k],u,w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update2(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update2(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;struct node&#123; int u; long long d; bool operator&lt;(const node&amp;h)const&#123;return d&gt;h.d;&#125;;&#125;;void dij()&#123; memset(dis,0x3f,sizeof(dis)); inf=dis[1]; priority_queue&lt;node&gt; q; dis[s]=0; q.push((node)&#123;s,0&#125;); while(!q.empty())&#123; node now=q.top(); int u=now.u; long long d=now.d; q.pop(); if(d!=dis[u])continue; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),s=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int opt=read(); if(opt==1)&#123; int x=read(),y=read(),z=read(); add(x,y,z); &#125; else if(opt==2)&#123; int u=read(),l=read(),r=read(),w=read(); update1(1,1,n,l,r,u,w); &#125; else&#123; int u=read(),l=read(),r=read(),w=read(); update2(1,1,n,l,r,u,w); &#125; &#125; dij(); for(int i=1;i&lt;=n;i++)&#123; if(dis[i]!=inf)&#123; printf("%I64d ",dis[i]); &#125; else printf("-1 "); &#125; return 0;&#125; 以上、]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F06%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World 咕到春节才写第一篇并且上线 语文差点垫底所以文笔较差多见谅(…以后估计也不会有什么长进 该博客大多是和OI相关的题解/游记/学习笔记/…有关的 也会发部分个人的总结之类的(?本质问号bot 12345#include&lt;cstdio&gt;int main()&#123; puts("Hello World"); return 0;&#125; 以上、]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
</search>
