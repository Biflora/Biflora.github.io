<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CF786B Legacy]]></title>
    <url>%2F2019%2F02%2F06%2FCF786B%2F</url>
    <content type="text"><![CDATA[http://codeforces.com/problemset/problem/786/B $Description$ 有$n$颗星球,$q$种方案,$s$为起点 方案分为三种 从$u_i$星球到$v_i$星球花费为$w_i$ 从$u_i$星球到$ \lbrack l_i,r_i \rbrack$星球花费为$w_i$ 从$ \lbrack l_i,r_i \rbrack$星球到$u_i$星球花费为$w_i$ 求出从$s$星球到每个星球的最小花费 $ Solution $ 处理区间建边显然是不能直接暴力加边的 考虑建一个虚点使加的边数量变少,而处理区间问题很好用的线段树就可以用上了 如图所示,建两棵线段树,分别自顶向下加边和自下向顶加边,分别对应单点向区间加边和区间向单点加边 只要在建出的图上跑一遍$dij$就过了 注意点:点数有$n$+$2nlogn$,边数最多有$2nlogn$+$mlogn$,数组要开大(一人血书提醒$Code$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffconst int N=100010;using namespace std;inline int read()&#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; struct edge&#123; int v,nxt,w;&#125;e[N*20];int head[N&lt;&lt;4],cnt;long long inf;int n,m,s;void add(int u,int v,int w)&#123; e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;int tin[N&lt;&lt;4],tout[N&lt;&lt;4],temp;long long dis[N&lt;&lt;4];void build(int k,int l,int r)&#123; if(l==r)&#123; tin[k]=tout[k]=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); tin[k]=++temp;tout[k]=++temp; add(tout[k&lt;&lt;1],tout[k],0); add(tout[k&lt;&lt;1|1],tout[k],0); add(tin[k],tin[k&lt;&lt;1],0); add(tin[k],tin[k&lt;&lt;1|1],0);&#125;void update1(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(u,tin[k],w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update1(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update1(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;void update2(int k,int l,int r,int L,int R,int u,int w)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; add(tout[k],u,w); return ; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=L)&#123; update2(k&lt;&lt;1,l,mid,L,R,u,w); &#125; if(mid&lt;R)&#123; update2(k&lt;&lt;1|1,mid+1,r,L,R,u,w); &#125;&#125;struct node&#123; int u; long long d; bool operator&lt;(const node&amp;h)const&#123;return d&gt;h.d;&#125;;&#125;;void dij()&#123; memset(dis,0x3f,sizeof(dis)); inf=dis[1]; priority_queue&lt;node&gt; q; dis[s]=0; q.push((node)&#123;s,0&#125;); while(!q.empty())&#123; node now=q.top(); int u=now.u; long long d=now.d; q.pop(); if(d!=dis[u])continue; for(int i=head[u];i;i=e[i].nxt)&#123; int v=e[i].v,w=e[i].w; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),s=read(); temp=n; build(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int opt=read(); if(opt==1)&#123; int x=read(),y=read(),z=read(); add(x,y,z); &#125; else if(opt==2)&#123; int u=read(),l=read(),r=read(),w=read(); update1(1,1,n,l,r,u,w); &#125; else&#123; int u=read(),l=read(),r=read(),w=read(); update2(1,1,n,l,r,u,w); &#125; &#125; dij(); for(int i=1;i&lt;=n;i++)&#123; if(dis[i]!=inf)&#123; printf("%I64d ",dis[i]); &#125; else printf("-1 "); &#125; return 0;&#125; 以上、]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F06%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World 咕到春节才写第一篇并且上线 语文差点垫底所以文笔较差多见谅(…以后估计也不会有什么长进 该博客大多是和OI相关的题解/游记/学习笔记/…有关的 也会发部分个人的总结之类的(?本质问号bot 12345#include&lt;cstdio&gt;int main()&#123; puts("Hello World"); return 0;&#125; 以上、]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
</search>
